var v=Object.defineProperty;var w=(i,e,t)=>e in i?v(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>(w(i,typeof e!="symbol"?e+"":e,t),t);import{y as C,l as k,z as d,A as P}from"./index-b9a19ad9.js";function u(i){if(typeof i!="object")return i;var e,t,s=Object.prototype.toString.call(i);if(s==="[object Object]"){if(i.constructor!==Object&&typeof i.constructor=="function"){t=new i.constructor;for(e in i)i.hasOwnProperty(e)&&t[e]!==i[e]&&(t[e]=u(i[e]))}else{t={};for(e in i)e==="__proto__"?Object.defineProperty(t,e,{value:u(i[e]),configurable:!0,enumerable:!0,writable:!0}):t[e]=u(i[e])}return t}if(s==="[object Array]"){for(e=i.length,t=Array(e);e--;)t[e]=u(i[e]);return t}return s==="[object Set]"?(t=new Set,i.forEach(function(n){t.add(u(n))}),t):s==="[object Map]"?(t=new Map,i.forEach(function(n,a){t.set(u(a),u(n))}),t):s==="[object Date]"?new Date(+i):s==="[object RegExp]"?(t=new RegExp(i.source,i.flags),t.lastIndex=i.lastIndex,t):s==="[object DataView]"?new i.constructor(u(i.buffer)):s==="[object ArrayBuffer]"?i.slice(0):s.slice(-6)==="Array]"?new i.constructor(i):i}class b{constructor(e){o(this,"_entityCount",0);o(this,"_entities",{});o(this,"numberOfMice");this.numberOfMice=e}getMouse(e){return this._entities[`${e}`]}isAlive(e){return this._entities[`${e}`].getComponent("isAlive").isAlive}createEntity(e){if(e||(e=this._entityCount.toString()),this._entities[e])throw new Error(`Entity with ID ${e} already exists`);const t=new M(e);return this._entities[t.id]=t,this._entityCount++,t}importEntities(e){this._entities={...this._entities,...e}}update(e){this.importEntities(e)}}class M{constructor(e){o(this,"id");o(this,"components",{});this.id=e}addComponent(e,t){this.components[e.compName]=e.init(t)}getComponent(e){return this.components[e]}}class g{constructor(){o(this,"compName","ap");o(this,"shape")}init(e){return{shape:e.shape??"mouse"}}}class y{constructor(e){o(this,"compName");o(this,"x");o(this,"y");this.compName=e}init(e){return{x:e.x??0,y:e.y??0}}}class S{constructor(e){o(this,"compName");o(this,"positions");this.compName=e,this.positions=[]}init(e){return this.positions=e,{positions:this.positions}}}class _{constructor(){o(this,"compName","isAlive");o(this,"isAlive")}init(e){return{isAlive:e??!1}}}class A{constructor(){o(this,"compName","map");o(this,"map")}init(e){this.map=Array(100);for(let t=0;t<100;t++){this.map[t]=new Array(100);for(let s=0;s<100;s++)t%20===0&&t!==0?this.map[t][s]={occupied:null,type:"underground"}:this.map[t][s]={occupied:null,type:"surface"}}return this.map[99][10]={occupied:null,type:"meeting"},this.map[20][10]={occupied:null,type:"entry"},this.map[20][80]={occupied:null,type:"entry"},this.map[40][90]={occupied:null,type:"entry"},this.map[40][20]={occupied:null,type:"entry"},this.map[60][10]={occupied:null,type:"entry"},this.map[60][30]={occupied:null,type:"entry"},this.map[80][90]={occupied:null,type:"entry"},this.map[80][10]={occupied:null,type:"entry"},this.map}}class O{constructor(){o(this,"numberOfMice",25);o(this,"mouseWinCounter",0);o(this,"mousePos");o(this,"mouseTargetList");o(this,"goalPos")}async updateMousePosition(e,t){return new Promise((s,n)=>{var h,l,c,p,m,f;this.mousePos=new r(e.getComponent("pos").x,e.getComponent("pos").y),this.mouseTargetList=e.getComponent("targetList").positions,this.goalPos=this.getCurrentGoalPosition();const a=this.calcStep();t.map[this.mousePos.x][this.mousePos.y].occupied=null,t.map[a.x][a.y].occupied=e,(a.x===((h=this.goalPos)==null?void 0:h.x)&&a.y===((l=this.goalPos)==null?void 0:l.y)||((c=this.mousePos)==null?void 0:c.x)===((p=this.goalPos)==null?void 0:p.x)&&((m=this.mousePos)==null?void 0:m.y)===((f=this.goalPos)==null?void 0:f.y))&&(this.mouseTargetList.length===0&&(e.getComponent("isAlive").isAlive=!1,this.mouseWinCounter++,s()),this.mouseTargetList.pop()),e.getComponent("pos").x=a.x,e.getComponent("pos").y=a.y,s()})}getInitialMouseX(){return Math.floor(Math.random()*100)}getInitialMouseY(){return Math.floor(Math.random()*100)}calcStep(){if(this.mousePos!==void 0&&this.mousePos.x!==void 0&&this.mousePos.y!==void 0&&this.goalPos!==void 0&&this.goalPos.x!==void 0&&this.goalPos.y!==void 0){const e=this.mousePos.x-this.goalPos.x,t=this.mousePos.y-this.goalPos.y;return e>0&&t!=0?t>0?new r(this.mousePos.x-1,this.mousePos.y-1):new r(this.mousePos.x-1,this.mousePos.y+1):e<0&&t!=0?t>0?new r(this.mousePos.x+1,this.mousePos.y-1):new r(this.mousePos.x+1,this.mousePos.y+1):t>0?new r(this.mousePos.x,this.mousePos.y-1):new r(this.mousePos.x,this.mousePos.y+1)}return this.goalPos}getCurrentGoalPosition(){return this.mouseTargetList!==void 0&&this.mouseTargetList.length!==void 0&&this.mouseTargetList.length>0?this.mouseTargetList[this.mouseTargetList.length-1]:this.goalPos}getNumberOfMice(){return this.numberOfMice}getMouseWinCounter(){return this.mouseWinCounter}killMouse(e){return this.numberOfMice>0&&e.components.isAlive!==!1?(this.numberOfMice--,e.components.isAlive=!1,console.log(e),console.log(this.numberOfMice),1):0}}class r{constructor(e,t){o(this,"x");o(this,"y");this.x=e,this.y=t}}class B{constructor(e,t,s,n){o(this,"logTag","[GameService]");o(this,"_settings");o(this,"gameFinished",!1);o(this,"peerService");o(this,"entitySystem");o(this,"map",C(new A));o(this,"numberOfMice");o(this,"currentState",k({}));o(this,"stateBuffer",{});o(this,"mouseHelper");o(this,"counter",0);o(this,"killCount",d({kills:0}));o(this,"winCount",d({wins:0}));this._settings=s??{gameId:"game1",multiplayer:!1,networked:!1},this.mouseHelper=new O,this.numberOfMice=this.mouseHelper.getNumberOfMice(),this.peerService=e,this.entitySystem=t??new b(this.numberOfMice),this.map.value.init()}async updateOpponentPosition(){for(let e=1;e<=this.numberOfMice;e++){const t=this.entitySystem.getMouse(e.toString());this.entitySystem.isAlive(t.id)&&await this.mouseHelper.updateMousePosition(t,this.map.value)}}startGame(e){this.currentState.value={players:{...this.generatePlayers(e)},opponents:{...this.generateOpponents()}},this.stateBuffer={...this.currentState.value},this._settings.multiplayer&&this._settings.networked&&this.peerService.send({type:"start_game",value:{state:this.currentState.value}}),window.requestAnimationFrame(this._gameLoop.bind(this))}generatePlayers(e=[]){const t={};for(const s of e){const n=this.entitySystem.createEntity(s);n.addComponent(new g,{shape:"cat"}),n.addComponent(new y("pos"),{x:50,y:50}),t[n.id]=n}return t}generateOpponents(){const e={};for(let t=0;t<this.numberOfMice;++t){const s=this.entitySystem.createEntity();s.addComponent(new g,{shape:"mouse"}),s.addComponent(new y("pos"),{x:this.mouseHelper.getInitialMouseX(),y:this.mouseHelper.getInitialMouseY()}),s.addComponent(new S("targetList"),this.generateMouseGoalList()),s.addComponent(new _,{isAlive:!0}),e[s.id]=s}return e}randomIntFromInterval(e,t){return Math.floor(Math.random()*(t-e+1)+e)}generateMouseGoalList(){const e=[];e.push(new r(85,10)),e.push(new r(this.randomIntFromInterval(0,99),this.randomIntFromInterval(0,99)));const t=this.randomIntFromInterval(1,3);return t==1||(t==2?e.push(new r(85,10)):t==3&&(e.push(new r(60,30)),e.push(new r(60,10)),e.push(new r(40,20)),e.push(new r(40,90)),e.push(new r(20,80)),e.push(new r(20,10)))),e}emit(e,t,s){const n=u(this.stateBuffer.players[e]);if(!n){console.warn(`${this.logTag} Entity with ID ${e} not found`);return}switch(t){case"move":this._handleMove(n,s);break}this.stateBuffer.players[e]=n}checkBorder(e,t){return!(this.map.value.map[e]==null||this.map.value.map[e][t]==null)}_handleMove(e,t){const s=e.getComponent("pos");switch(t){case"up":if(!this.checkBorder(s.x-1,s.y))break;this.map.value.map[s.x][s.y].occupied=null,s.x=s.x-1,this.checkCollision(s.x,s.y),this.map.value.map[s.x][s.y].occupied=e;break;case"right":if(!this.checkBorder(s.x,s.y+1))break;this.map.value.map[s.x][s.y].occupied=null,s.y=s.y+1,this.checkCollision(s.x,s.y),this.map.value.map[s.x][s.y].occupied=e;break;case"left":if(!this.checkBorder(s.x-1,s.y-1))break;this.map.value.map[s.x][s.y].occupied=null,s.y=s.y-1,this.checkCollision(s.x,s.y),this.map.value.map[s.x][s.y].occupied=e;break;case"down":if(!this.checkBorder(s.x+1,s.y))break;this.map.value.map[s.x][s.y].occupied=null,s.x=s.x+1,this.checkCollision(s.x,s.y),this.map.value.map[s.x][s.y].occupied=e;break;default:console.warn(`${this.logTag} Unknown direction ${t}`)}}checkCollision(e,t){this.killChecker(e,t),e=e-1,this.killChecker(e,t),e=e+2,this.killChecker(e,t),e=e-1,t=t-1,this.killChecker(e,t),t=t+2,this.killChecker(e,t),e=e+1,this.killChecker(e,t),t=t-2,this.killChecker(e,t),e=e-2,this.killChecker(e,t),t=t+2,this.killChecker(e,t)}killChecker(e,t){var s,n,a;if(t>=0&&t<100&&e>=0&&e<100&&this.map.value.map[e][t].occupied!=null&&this.map.value.map[e][t].type!="underground"&&((s=this.map.value.map[e][t].occupied)==null?void 0:s.getComponent("ap").shape)=="mouse"&&((n=this.map.value.map[e][t].occupied)==null?void 0:n.getComponent("isAlive").isAlive)!=!1){const h=(a=this.map.value.map[e][t].occupied)==null?void 0:a.id,l=this.entitySystem.getMouse(h.toString());this.killCount.kills+=this.mouseHelper.killMouse(l)}}async _gameLoop(){this.counter++,this.counter%7===0&&(this.counter=0,await this.updateOpponentPosition(),this.winCount.wins=this.mouseHelper.getMouseWinCounter()),P(this.map),this._settings.multiplayer&&this._settings.networked&&this.peerService.send({type:"update",value:this.stateBuffer}),this.entitySystem.update(this.stateBuffer.players),this.entitySystem.update(this.stateBuffer.opponents),this.stateBuffer={...this.currentState.value},this.gameFinished!==!0&&window.requestAnimationFrame(this._gameLoop.bind(this))}}export{B as G};
