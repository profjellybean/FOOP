var C=Object.defineProperty;var k=(n,e,t)=>e in n?C(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var r=(n,e,t)=>(k(n,typeof e!="symbol"?e+"":e,t),t);import{r as S,C as g,D as M,B as I,h as E,p as O,E as A}from"./index-ff08295f.js";function p(n){if(typeof n!="object")return n;var e,t,i=Object.prototype.toString.call(n);if(i==="[object Object]"){if(n.constructor!==Object&&typeof n.constructor=="function"){t=new n.constructor;for(e in n)n.hasOwnProperty(e)&&t[e]!==n[e]&&(t[e]=p(n[e]))}else{t={};for(e in n)e==="__proto__"?Object.defineProperty(t,e,{value:p(n[e]),configurable:!0,enumerable:!0,writable:!0}):t[e]=p(n[e])}return t}if(i==="[object Array]"){for(e=n.length,t=Array(e);e--;)t[e]=p(n[e]);return t}return i==="[object Set]"?(t=new Set,n.forEach(function(s){t.add(p(s))}),t):i==="[object Map]"?(t=new Map,n.forEach(function(s,a){t.set(p(a),p(s))}),t):i==="[object Date]"?new Date(+n):i==="[object RegExp]"?(t=new RegExp(n.source,n.flags),t.lastIndex=n.lastIndex,t):i==="[object DataView]"?new n.constructor(p(n.buffer)):i==="[object ArrayBuffer]"?n.slice(0):i.slice(-6)==="Array]"?new n.constructor(n):n}var v=(n=>(n.INIT="onInit",n.PEER_CONNECTION="onPeerConnection",n.PEER_DISCONNECTED="onPeerDisconnected",n.PEER_ERROR="onPeerError",n))(v||{});const H=n=>{let e;switch(n.id){case"map":e=new _,e.init(n);break;case"pos":case"goal":e=new f(n.id),e.init(n);break;case"ap":e=new y,e.init(n);break;case"isAlive":e=new b,e.init(n.isAlive);break;case"targetList":e=new w(n.id),e.init(n.positions);break;default:throw new Error(`Unknown component type ${n.id}`)}return e};class y{constructor(){r(this,"id","ap");r(this,"shape")}init(e){return this.shape=e.shape??"mouse",this}}class f{constructor(e){r(this,"id");r(this,"x");r(this,"y");this.id=e}init(e){return this.x=e.x??0,this.y=e.y??0,this}}class w{constructor(e){r(this,"id");r(this,"positions");this.id=e,this.positions=[]}init(e){return this.positions=e,this}}class b{constructor(){r(this,"id","isAlive");r(this,"isAlive")}init(e){return this.isAlive=e??!1,this}}class _{constructor(){r(this,"id","map");r(this,"map")}init(e){this.map=Array(100);for(let t=0;t<100;t++){this.map[t]=new Array(100);for(let i=0;i<100;i++)t%20===0&&t!==0?this.map[t][i]={occupied:null,type:"underground"}:this.map[t][i]={occupied:null,type:"surface"}}return this.map[85][10]={occupied:null,type:"meeting"},this.map[20][10]={occupied:null,type:"entry"},this.map[20][80]={occupied:null,type:"entry"},this.map[40][90]={occupied:null,type:"entry"},this.map[40][20]={occupied:null,type:"entry"},this.map[60][10]={occupied:null,type:"entry"},this.map[60][30]={occupied:null,type:"entry"},this.map[80][90]={occupied:null,type:"entry"},this.map[80][10]={occupied:null,type:"entry"},this}}class x{constructor(e){r(this,"_entityCount",0);r(this,"_entities",{});r(this,"numberOfMice");this.numberOfMice=e}getMouse(e){return this._entities[e]}isAlive(e){return this._entities[e].getComponent("isAlive").isAlive}createEntity(e){if(e||(e=this._entityCount.toString()),this._entities[e])throw new Error(`Entity with ID ${e} already exists`);const t=new d(e);return this._entities[t.id]=t,this._entityCount++,t}importEntities(e){const t={};for(const i in e)this._entities[i]&&console.error(`Entity with ID ${i} already exists; I assume that this entity is the same, won't import...`),this._entities[i]=t[i]=d.fromJson(e[i]);return this._entityCount=Object.keys(this._entities).length,t}}class d{constructor(e){r(this,"id");r(this,"components",{});this.id=e}static fromJson(e){const t=new d(e.id);for(const i in e.components)t.components[i]=H(e.components[i]);return t}addComponent(e,t){this.components[e.id]=e.init(t)}getComponent(e){return this.components[e]}}class B{constructor(){r(this,"numberOfMice",25);r(this,"mouseWinCounter",0)}async updateMousePosition(e,t){return new Promise((i,s)=>{const a=new o(e.getComponent("pos").x,e.getComponent("pos").y),h=e.getComponent("targetList").positions,l=this.getCurrentGoalPosition(h),m=e.getComponent("isAlive");if(l===void 0&&m.isAlive===!1){i();return}if(l===void 0&&m.isAlive===!0){console.error("Mouse is alive but has no goal position"),s();return}const c=this.calcStep(a,l);if((c==null?void 0:c.x)===(l==null?void 0:l.x)&&(c==null?void 0:c.y)===(l==null?void 0:l.y)||(a==null?void 0:a.x)===(l==null?void 0:l.x)&&(a==null?void 0:a.y)===(l==null?void 0:l.y)){if(h.length===0){m.isAlive=!1,this.mouseWinCounter++,i();return}console.log(h),h.pop()}if(c===void 0){console.error("Mouse has no new position"),s();return}t.map[a.x][a.y].occupied=null,t.map[c.x][c.y].occupied=e,e.getComponent("pos").x=c.x,e.getComponent("pos").y=c.y,i()})}getInitialMouseX(){return Math.floor(Math.random()*100)}getInitialMouseY(){return Math.floor(Math.random()*100)}calcStep(e,t){if(e!==void 0&&e.x!==void 0&&e.y!==void 0&&t!==void 0&&t.x!==void 0&&t.y!==void 0){const i=e.x-t.x,s=e.y-t.y;return i>0&&s!=0?s>0?new o(e.x-1,e.y-1):new o(e.x-1,e.y+1):i<0&&s!=0?s>0?new o(e.x+1,e.y-1):new o(e.x+1,e.y+1):s>0?new o(e.x,e.y-1):new o(e.x,e.y+1)}return t}getCurrentGoalPosition(e){if(e!==void 0&&e.length!==void 0&&e.length>0)return e[e.length-1]}getNumberOfMice(){return this.numberOfMice}getMouseWinCounter(){return this.mouseWinCounter}killMouse(e){return this.numberOfMice>0&&e.components.isAlive.isAlive!==!1?(this.numberOfMice--,e.components.isAlive.isAlive=!1,console.log(e),console.log(this.numberOfMice),1):0}}class o{constructor(e,t){r(this,"x");r(this,"y");this.x=e,this.y=t}static fromComponent(e){return new o(e.x,e.y)}}var u=(n=>(n[n.initial=0]="initial",n[n.started=1]="started",n[n.finished=2]="finished",n[n.paused=3]="paused",n[n.error=4]="error",n))(u||{});class D{constructor(e,t){r(this,"logTag","[GameService]");r(this,"_settings");r(this,"context",{});r(this,"gameFinished",!1);r(this,"peerService");r(this,"entitySystem");r(this,"map",new _);r(this,"numberOfMice");r(this,"currentState",S({}));r(this,"stateBuffer",{});r(this,"mouseHelper");r(this,"counter",0);r(this,"killCount",g({kills:0}));r(this,"winCount",g({wins:0}));r(this,"_router");r(this,"_multiplayerUpdater");r(this,"gameLoopPlayer",M(this._gameLoop.bind(this),{immediate:!1}));this._settings=t??{multiplayer:!1,networked:!1},this.mouseHelper=new B,this.numberOfMice=this.mouseHelper.getNumberOfMice(),this.entitySystem=e??new x(this.numberOfMice),this.map.init(),window.addEventListener("pagehide",()=>{this.gameLoopPlayer.pause()}),I(this.currentState,i=>{console.log("new state",i)})}async updateOpponentPosition(){for(let e=0;e<this.numberOfMice;e++){const t=this.currentState.value.opponents[e.toString()];this.entitySystem.isAlive(t.id)&&await this.mouseHelper.updateMousePosition(t,this.map)}}initMultiplayer(){const{peerService:e}=E();if(this.peerService=e.value,this._settings.multiplayer&&this._settings.networked){if(this.peerService.lobbySettings.lobbyId===null)throw new Error(this.logTag+" Cannot start game without lobbyId");if(!this.peerService.peer)return;this.context.gameId=this.peerService.lobbySettings.lobbyId,console.log("pre sync state",this.currentState.value),this.context.gameId===this.peerService.peer.id?this.peerService.dataHandler.registerHandler("sync_ack",this._handleInitialSyncAck.bind(this)):this.peerService.dataHandler.registerHandler("initial_state_sync",this._handleInitialSync.bind(this)),this._router=O,this._multiplayerUpdater=A(this._updatePeers,30)}}_updatePeers(){this.peerService.send({type:"update",value:{players:{[this.peerService.peer.id]:this.stateBuffer.players[this.peerService.peer.id]}}})}startGame(e){var t;this.currentState.value={players:this.generatePlayers(e),opponents:this.generateOpponents()},this._settings.multiplayer&&this._settings.networked?(this.peerService.setHook(v.PEER_CONNECTION,i=>this.context.status===u.started&&!this.context.players[i.peer]?(console.error(this.logTag+" Peer cannot connect to game, game is already running"),i.removeAllListeners(),i.close(),!1):!0),(t=this.peerService)!=null&&t.peer&&(this.context.players=this.peerService.peerConnections.map(i=>({[i.peer]:{id:i.peer,ready:!1}})).reduce((i,s)=>({...i,...s}),{}),this.peerService.send({type:"initial_state_sync",value:this.currentState.value}))):(this.context.status=u.started,this.gameLoopPlayer.resume())}pauseGame(){this._settings.multiplayer&&this._settings.networked&&this.peerService.send({type:"pause_game"}),this.gameLoopPlayer.pause()}generatePlayers(e=[]){const t={};for(const i of e){const s=this.entitySystem.createEntity(i);s.addComponent(new y,{shape:"cat"}),s.addComponent(new f("pos"),{x:50,y:50}),t[s.id]=s}return t}generateOpponents(){const e={};for(let t=0;t<this.numberOfMice;++t){const i=this.entitySystem.createEntity(t.toString());i.addComponent(new y,{shape:"mouse"}),i.addComponent(new f("pos"),{x:this.mouseHelper.getInitialMouseX(),y:this.mouseHelper.getInitialMouseY()}),i.addComponent(new w("targetList"),this.generateMouseGoalList()),i.addComponent(new b,{isAlive:!0}),e[i.id]=i}return e}randomIntFromInterval(e,t){return Math.floor(Math.random()*(t-e+1)+e)}generateMouseGoalList(){const e=[];e.push(new o(85,10)),e.push(new o(this.randomIntFromInterval(0,99),this.randomIntFromInterval(0,99)));const t=this.randomIntFromInterval(1,3);return t==1||(t==2?e.push(new o(85,10)):t==3&&(e.push(new o(60,30)),e.push(new o(60,10)),e.push(new o(40,20)),e.push(new o(40,90)),e.push(new o(20,80)),e.push(new o(20,10)))),e}async emit(e,t,i){this.stateBuffer.players===void 0&&(this.stateBuffer.players={}),this.stateBuffer.players[e]===void 0&&(this.stateBuffer.players[e]=p(this.currentState.value.players[e]));const s=this.stateBuffer.players[e];if(!s){console.warn(`${this.logTag} Entity with ID ${e} not found`);return}switch(t){case"move":this._handleMove(s,i);break}this.stateBuffer.players[e]=s}checkBorder(e,t){return!(this.map.map[e]==null||this.map.map[e][t]==null)}_handleMove(e,t){const i=e.getComponent("pos");switch(t){case"up":if(!this.checkBorder(i.x,i.y-1))break;this.map.map[i.x][i.y].occupied=null,i.y=i.y-1,this.checkCollision(i.x,i.y),this.map.map[i.x][i.y].occupied=e;break;case"right":if(!this.checkBorder(i.x+1,i.y))break;this.map.map[i.x][i.y].occupied=null,i.x=i.x+1,this.checkCollision(i.x,i.y),this.map.map[i.x][i.y].occupied=e;break;case"left":if(!this.checkBorder(i.x-1,i.y))break;this.map.map[i.x][i.y].occupied=null,i.x=i.x-1,this.checkCollision(i.x,i.y),this.map.map[i.x][i.y].occupied=e;break;case"down":if(!this.checkBorder(i.x,i.y+1))break;this.map.map[i.x][i.y].occupied=null,i.y=i.y+1,this.checkCollision(i.x,i.y),this.map.map[i.x][i.y].occupied=e;break;default:console.warn(`${this.logTag} Unknown direction ${t}`)}}checkCollision(e,t){this.killChecker(e,t),e=e-1,this.killChecker(e,t),e=e+2,this.killChecker(e,t),e=e-1,t=t-1,this.killChecker(e,t),t=t+2,this.killChecker(e,t),e=e+1,this.killChecker(e,t),t=t-2,this.killChecker(e,t),e=e-2,this.killChecker(e,t),t=t+2,this.killChecker(e,t)}killChecker(e,t){var i,s,a;if(t>=0&&t<100&&e>=0&&e<100&&this.map.map[e][t].occupied!=null&&this.map.map[e][t].type!="underground"&&((i=this.map.map[e][t].occupied)==null?void 0:i.getComponent("ap").shape)=="mouse"&&((s=this.map.map[e][t].occupied)==null?void 0:s.getComponent("isAlive").isAlive)!=!1){const h=(a=this.map.map[e][t].occupied)==null?void 0:a.id,l=this.currentState.value.opponents[h.toString()];this.killCount.kills+=this.mouseHelper.killMouse(l)}}async _gameLoop(){if(this.counter++,this.counter%7===0&&(this.counter=0,await this.updateOpponentPosition(),this.winCount.wins=this.mouseHelper.getMouseWinCounter()),this.stateBuffer.players!==void 0&&Object.keys(this.stateBuffer.players).length>0&&(this._settings.multiplayer&&this._settings.networked&&this.stateBuffer.players[this.peerService.peer.id]!==void 0&&this._multiplayerUpdater(),this._updateEntityMap(this.currentState.value.players,this.stateBuffer.players)),this.stateBuffer={players:{},opponents:{}},this.gameFinished===!0){this.gameLoopPlayer.pause();return}}async _handleInitialSync(e,t){console.log(this.logTag+" handling initial sync");const i=this.entitySystem.importEntities(t.value.players),s=this.entitySystem.importEntities(t.value.opponents);this.currentState.value={players:i,opponents:s};const a=e.peerService.peerConnections.filter(h=>h.peer===e.peerService.lobbySettings.lobbyId)[0];a||console.error(this.logTag+" Cannot find host connection"),this.context.status=u.started,await this._router.push({name:"multiplayer_game",params:{gameId:this.context.gameId}}),console.log(this.logTag+" sending sync ack to host"),a.send({type:"sync_ack"}),this.peerService.dataHandler.removeHandler("initial_state_sync"),this.peerService.dataHandler.registerHandler("start_game",this._handleStartGame.bind(this)),console.log("initial sync post state",this.currentState.value)}async _handleInitialSyncAck(e,t){if(console.log(this.logTag+" handle sync_ack data"),!this.context.players){console.log(this.logTag+" got handleSyncAck but no players");return}const i=this.context.players[e.senderId];if(!i){console.warn(this.logTag+" Got initial handle async from peer id: "+e.senderId+" but no player was found in context");return}i.ready=!0,Object.values(this.context.players).every(s=>s.ready===!0)&&(this.context.status=u.started,await this._router.push({name:"multiplayer_game",params:{gameId:this.context.gameId}}),this.peerService.send({type:"start_game",value:this.context.gameId}),this._registerInGameHandlers(),this.gameLoopPlayer.resume(),console.log("initial sync post state",this.currentState.value))}_registerInGameHandlers(){this.peerService.dataHandler.registerHandler("pause_game",this._handlePauseGame.bind(this)),this.peerService.dataHandler.registerHandler("update",this._handleUpdate.bind(this))}async _handleStartGame(e,t){console.log(this.logTag+" Starting gaame"),this._registerInGameHandlers(),this.gameLoopPlayer.resume()}async _handlePauseGame(e,t){console.log(this.logTag+" Pausing game"),this.context.status=u.paused,this.gameLoopPlayer.pause()}async _handleUpdate(e,t){console.log(this.logTag+" Updating game");const i=t.value.players;this._updateEntityMap(this.stateBuffer.players,i,!0)}_updateEntityMap(e,t,i=!1){const s=Object.keys(t);for(let a=0;a<s.length;++a){if(!e[s[a]]){if(!i){console.warn(`${this.logTag} Entity with ID ${s[a]} not found`);continue}e[s[a]]=d.fromJson(t[s[a]])}e[s[a]].components=t[s[a]].components}}}export{u as G,D as a};
